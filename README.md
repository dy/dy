Software servant.


<!-- Normcore DX semiconductor. -->
<!-- Converging perfection. Eclectic engineering. -->
<!-- Software scriptures? Sacred engineering? Confessing code? Debugging penances? Code prayers? Syntax monk? Compiling verses? Software slokas? Debhajan? Refactoring rituals? -->


<!--
DRY: Don't repeat yourself.
SOC: Separate Concerns, one reason to change.
Make it work, make it right, make it fast. 
Best design is no design.
YAGNI: Don't build what you don't need yet
KISS: Complexity is debt
Fail first: surface errors early.
Convention over Configuration: sane defaults.
Principle of Least Astonishment: Predictable behavior
Perfection is not when nothing to add, but to remove.
Prefer elegant, sattvic, aesthetic, ergonomic, practical DX, UX, AX.
Code style is minimal, functional, clear and streamlined, concise, clever, eclectic.
Software as a service to Krishna, see [krishnized license](https://github.com/krishnized/license).
Find inspiring and relevant use cases, analyze value, opportunities, perspectives, hidden gems. Point at obvious defects, omitments, confusions and redundancies.
For variable naming the best is abbreviated naming.
For phrases the best is tricolon or less.
-->

<!--
Before giving task:
- What value? What focus? What goal? Which problems can it solve?
- What info is necessary? What are known solutions? What alternatives are doing?
- What risks to avoid?
- What would be good result? Excellent result?
- What are the best / worst parts of competitors?
- What is the most meaningful way to get it done? The best organization of work?
- Which are main use-cases? Which are indirect / hidden use-cases? Unusual use-cases?
- What's the minimum viable scope/product? What's out of scope? What the solution should not be?
- What best practices / patterns to follow?
- What already exists that solves this?
- What dependencies exist? What limitations exist?
- What edge cases matter? 
- What will I need to verify?
- What would you benefit from using?
- What am I not seeing?
- What decision will unblock the progress?
- What are best practices?

After completing each task do thorough analysis:
- Does the result match intent?
- What's unclear or surprising? What's confusing?
- What's cognitive load to understand it? can it be simplified?
- What is redundant? What violates DRY?
- what can be enhanced? what can be reduced to bare form?
- What is coupled that should not be?
- What names are unclear? What names are excessively long?
- What are defects - aesthetically, ergonomically, qualitatively, weight bloat, memory risk, performance bottlenecks?
- What tests are missing? 
- What docs would future me need? What docs would be needed for agents?
- What would make this embarassing in 6 months? 
- What would make it future-proof, eternal, canonic form?
- What would make it excellent?
- What are best practices missing?
- What complicates integration?
-->



ðŸ”­ [watr](https://github.com/dy/watr), [jz](https://github.com/dy/jz)
